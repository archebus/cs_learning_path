# Comp-Sci for Autodidacts and Lunatics

DISCLAIMER: This isn’t a “get a dev job in 3 weeks” course. It’s full-send into a rabbit hole of comp-sci obsession.

* **Is this learning path easy?** No.
* **Who is this for?** People who can't study at university, but still want to learn. People who need structure. Geeks and Nerds who want to peel back the layers of abstraction and understand what's really going on.
* **Is it free?** Most resources are free or can be found if you're _resourceful_. Use your best judgment.
* **Isn't this just a bunch of other learning resources strung together?** Yes.
* **Is the mathematics optional?** No. *(Maths is foundational, I thought I could skip it. Turns out I couldn't if I wanted to learn everything.)*
* **Why did you make this?** I am not able to study at university, but still wanted to learn "*everything*". Everything turned out to be too big, so I needed a plan. Below is the plan I came up with, and then I modified it slightly to make it fit for public consumption.
* **Where do I get book x?** You buy them. Books make you look smart. Put them on a shelf and impress your friends. Otherwise see "is this course free".

---

## How to Use This Guide
* **🔹 Blue Diamonds** = Core curriculum. Generally advised to NOT SKIP this context.
* **🔸 Orange Diamonds** = Supplementary materials. Do you want *moar*? Then do these as well.

**Learning Approach:**
- Progress through courses sequentially, but feel free to explore supplementary materials as interests arise. This course is meant to cover everything, and I wanted to suggest (in my opinion) the GOLD STANDARD for resources.
  
- Every major topic includes hands-on projects - these are not optional. See one, do one, teach one. I've provided guidance for the seeing and the doing. It's how to learn.
  
- Document, take notes, put your projects in a portfolio.
  
- Self-paced means exactly that - take the time you need to truly understand each concept. There are no looming deadlines, and no teachers. This also means you need some discipline.
  
### **Regarding AI**:

AI is a tool that amplifies the baseline desire of the user interacting with it. Heard the claim "AI makes you dumber", yeah it does ... if you use it in a dumb way.

But when an engaged learner interacts with an LLM it just amplifies the ability for that user to ask highly critical and directed questions about a topic. Or to act as a springboard to validate ideas.

**Get good at prompting.** Proper use of AI massively accelerate your rate of learning. Just don't ask it to "solve" the problem you are facing => **Don't outsource your thinking.**

Example: 
'What are the edge cases in my shell implementation?' 
VS
'Write my shell for me'"

---
## Course 1: Foundations

### Mathematics Track
**Start Here:**
- [ ] 🔹 Khan Academy: Pre-Algebra → Algebra 1 → Algebra 2 → Precalculus

### Computer Science Fundamentals Track
**Start Here:**
- [ ] 🔹 CS50 (Harvard)
    - [ ] 🔹 Project: CS50 comes with plenty of projects. Do them.
- [ ] 🔹 "The C Programming Language" - Kernighan & Ritchie
    - [ ] 🔹 Project: Complete all book exercises
    - [ ] 🔹 Project: Build CLI tools (calculator, text editor, file utilities)

**Supplementary:**
- [ ] 🔸 "Code: The Hidden Language of Computer Hardware and Software" - Petzold
- [ ] 🔸 "The Practice of Programming" - Kernighan & Pike
- [ ] 🔸 "Pro Git" - Master version control workflows
- [ ] 🔸 Shell and build tools mastery (make, gcc, valgrind, gdb)

---

## Course 2: Systems & Mathematics
### Applied Mathematics Track
**Start Here:**
- [ ] 🔹 Khan Academy: Linear Algebra + Statistics and Probability

**Supplementary:**
- [ ] 🔸 "Linear Algebra Done Right" - Axler
- [ ] 🔸 "The Elements of Statistical Learning" - Hastie, Tibshirani, Friedman

### Operating Systems Track
**Start Here:**
- [ ] 🔹 "Operating Systems: Three Easy Pieces"
    - [ ] 🔹 Project: Build a shell with job control, piping, and background tasks

**Supplementary:**
- [ ] 🔸 MIT Missing Semester
- [ ] 🔸 "Understanding the Linux Kernel"
- [ ] 🔸 "Modern Operating Systems" - Tanenbaum
- [ ] 🔸 "The Art of Unix Programming" - Raymond
- [ ] 🔸 "The Unix Programming Environment" - Kernighan & Pike
- [ ] 🔸 "Classic Shell Scripting" or "Linux Command Line and Shell Scripting Bible"

### Database Fundamentals Track
**Start Here:**
- [ ] 🔹 "Database System Concepts" - Silberschatz, Galvin, Gagne
    - [ ] 🔹 Project: Build a blog or forum with CRUD operations and indexing

---
##  Course 3: Web Development & Modern Programming

### Web Development Track
**Start Here:**
- [ ] 🔹 The Odin Project: Full Course, React Path.
    - [ ] 🔹 Project: Build a full-stack social media platform.
- [ ] 🔹 "You Don't Know JS" (book series) - Kyle Simpson
    - [ ] 🔹  Project: Complete all exercises.
     
**Supplementary:**
- [ ] 🔸 "HTTP: The Definitive Guide" - David Gourley & Brian Totty
- [ ] 🔸 "High Performance Browser Networking" - Ilya Grigorik
- [ ] 🔸 "Designing Web APIs" - Brenda Jin, Saurabh Sahni, Amir Shevat
- [ ] 🔸 Modern CSS architecture (CSS Grid, Flexbox, CSS-in-JS)

---

## Course 4: Networking & Discrete Mathematics

### Discrete Mathematics Track
**Start Here:**
- [ ] 🔹 "Mathematics for Computer Science" - MIT OCW
- [ ] 🔹 "How to Prove It" - Velleman

**Supplementary:**
- [ ] 🔸 Khan Academy: Discrete Mathematics
- [ ] 🔸 "Discrete Mathematics and Its Applications" - Rosen
- [ ] 🔸 "The Art of Proof" - Beck

### Networking & Security Track
**Start Here:**
- [ ] 🔹 "Computer Networking: A Top-Down Approach" - Kurose & Ross
    - [ ] 🔹 Project: Build multi-threaded HTTP server with WebSocket support
- [ ] 🔹 "Hacking: The Art of Exploitation" - Erickson
    - [ ] 🔹 Project: Complete all exercises and participate in CTF

**Supplementary:**
- [ ] 🔸 "TCP/IP Illustrated" - Stevens
- [ ] 🔸 "High Performance Browser Networking" - Grigorik
- [ ] 🔸 "The Web Application Hacker's Handbook"
- [ ] 🔸 "Security Engineering" - Anderson
- [ ] 🔸 "Serious Cryptography" - Aumasson

---

## Course 5: Algorithms & Systems Architecture

### Algorithms & Theory Track

**Start Here:**
- [ ] 🔹 "Introduction to Algorithms" - Cormen, Leiserson, Rivest, Stein (CLRS)
    - [ ] 🔹 Project: Implement core data structures and algorithms from scratch in C or Rust
- [ ] 🔹 "Introduction to the Theory of Computation" - Sipser

**Supplementary:**
- [ ] 🔸 "Algorithms" - Sedgewick & Wayne
- [ ] 🔸 "Concrete Mathematics" - Knuth, Patashnik, Graham

### Systems Deep Dive Track

**Start Here:**
- [ ] 🔹 "Computer Systems: A Programmer's Perspective" (CS:APP)
    - [ ] 🔹 Project: Build and optimize a memory allocator
- [ ] 🔹 Nand2Tetris
    - [ ] 🔹 Project: Complete full hardware/software stack

**Supplementary:**
- [ ] 🔸 "Compilers: Principles, Techniques & Tools" (Dragon Book)
- [ ] 🔸 "Computer Organization and Design" - Patterson & Hennessy
- [ ] 🔸 "Computer Architecture: A Quantitative Approach"
- [ ] 🔸 "The Art of Electronics"
- [ ] 🔸 "Digital Design and Computer Architecture"

---

## Specialization Tracks
> Choose one or more areas for deep specialization after completing the core curriculum.

### Security Research Track

**Start Here:**
- [ ] 🔹 "The Web Application Hacker's Handbook"
    - [ ] 🔹 Project: Discover and responsibly disclose a security vulnerability

**Supplementary:**
- [ ] 🔸 "Security Engineering" - Anderson
- [ ] 🔸 CVE analysis and security research
- [ ] 🔸 Advanced CTF participation

### Systems Architecture Track
**Start Here:**
- [ ] 🔹 "Designing Data-Intensive Applications" - Kleppmann
    - [ ] 🔹 Project: Build a distributed system or key-value store

**Supplementary:**
- [ ] 🔸 "Site Reliability Engineering" - Google
- [ ] 🔸 Advanced database internals study

### Low-Level Mastery Track
**Start Here:**
- [ ] 🔹 "Linux Kernel Development" - Love
    - [ ] 🔹 Project: Write a kernel module or contribute to kernel development

**Supplementary:**
- [ ] 🔸 "Understanding the Linux Kernel"
- [ ] 🔸 "Modern Processor Design" - Shen

### Language & Compiler Track
**Start Here:**
- [ ] 🔹 "Structure and Interpretation of Computer Programs" (SICP)
    - [ ] 🔹 Project: Build a programming language interpreter or compiler

**Supplementary:**
- [ ] 🔸 "Design Concepts in Programming Languages"
- [ ] 🔸 "Types and Programming Languages" - Pierce

### AI/ML Research Track
**Start Here:**
- [ ] 🔹 "Hands-On Machine Learning" - Géron
    - [ ] 🔹 Project: Train and deploy a machine learning model

**Supplementary:**
- [ ] 🔸 "Artificial Intelligence: A Modern Approach" - Russell & Norvig
- [ ] 🔸 "Pattern Recognition and Machine Learning" - Bishop
- [ ] 🔸 FastAI or DeepLearning.ai courses

### Functional Programming Track
**Start Here:**
- [ ] 🔹 "Programming Elixir" or "Haskell Programming from First Principles"
    - [ ] 🔹 Project: Build a functional application in chosen language

**Supplementary:**
- [ ] 🔸 "Learn You a Haskell for Great Good"
- [ ] 🔸 Advanced functional programming concepts

---
## Development Environment & Meta-Skills

### Essential Tools
**Start Here:**
- [ ] 🔹 Vim or Emacs mastery (essential in lower level environments)
- [ ] 🔹 Advanced Git workflows and version control

**Supplementary:**
- [ ] 🔸 Window managers (i3, tmux, tiling workflows)
- [ ] 🔸 Build systems (make, cmake, ninja)
- [ ] 🔸 Package managers and containerization
- [ ] 🔸 IDE configuration and plugins

### Knowledge Management
**Start Here:**
- [ ] 🔹 Build a second brain -> (Obsidian, Notion, or GitHub)
- [ ] 🔹 Technical writing practice (blog posts, documentation)

**Supplementary:**
- [ ] 🔸 Conference talks and research paper reading
- [ ] 🔸 Community participation and networking

---

## Project Portfolio Requirements

Throughout the curriculum, maintain a portfolio demonstrating:
- [ ] 🔹 All major projects from each course with clean, documented code
- [ ] 🔹 Progressive skill development across multiple programming languages
- [ ] 🔹 At least one significant open-source contribution
- [ ] 🔹 Technical writing samples and documentation

---

## Milestones & Completion Criteria

### Intermediate Milestones
A loose idea of capabilities after each course:
- **Course 1**: Write and debug C programs, understand basic computer architecture
- **Course 2**: Understand operating system internals, work with databases, solve linear algebra problems
- **Course 3**: Create full stack web applications, insight into the frameworks behind the web
- **Course 4**: Implement network protocols, understand cryptographic principles, write mathematical proofs
- **Course 5**: Analyze algorithm complexity, design system architectures, optimize low-level code

### Mastery Checks
Can you do these things?
- [ ] 🔹 Implement core algorithms and data structures from memory
- [ ] 🔹 Debug and optimize system-level code
- [ ] 🔹 Design and implement distributed systems
- [ ] 🔹 Contribute meaningfully to open-source projects
- [ ] 🔹 Explain complex CS concepts clearly to others
- [ ] 🔹 Choose appropriate tools and technologies for given problems

---

_This curriculum is open source and community-driven. Contributions, suggestions, and improvements are welcome._
